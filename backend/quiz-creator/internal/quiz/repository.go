package quiz

import (
	"database/sql"
	"fmt"

	_ "github.com/lib/pq"
	"github.com/lucsky/cuid"
)

// QuizRepository handles database insertion operations for quizzes.
type QuizRepository struct {
	db *sql.DB
}

// NewQuizRepository returns a new instance of QuizRepository.
func NewQuizRepository(db *sql.DB) *QuizRepository {
	return &QuizRepository{db: db}
}

func (qr *QuizRepository) GetAllQuizzes() ([]map[string]interface{}, error) {
	// Exécution de la requête pour récupérer les quizzes
	rows, err := qr.db.Query(`SELECT "quizId", "quiz" FROM "Quizzes"`)
	if err != nil {
		return nil, fmt.Errorf("failed to query quizzes: %w", err)
	}
	defer rows.Close()

	var quizzes []map[string]interface{}
	// Parcours des lignes
	for rows.Next() {
		var quizId, quiz string
		// Extraction des données de chaque ligne
		if err := rows.Scan(&quizId, &quiz); err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		// Récupérer les questions associées à ce quiz
		questions, err := qr.getQuestionsForQuiz(quizId)
		if err != nil {
			return nil, fmt.Errorf("failed to get questions for quiz %s: %w", quizId, err)
		}

		// Création d'un objet pour ce quiz avec les questions associées
		quizData := map[string]interface{}{
			"quizId":    quizId,
			"quiz":      quiz,
			"questions": questions,
		}

		// Ajout du quiz avec les questions au tableau
		quizzes = append(quizzes, quizData)
	}

	// Vérifie si une erreur s'est produite pendant l'itération
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating rows: %w", err)
	}

	return quizzes, nil
}

// Fonction auxiliaire pour récupérer les questions associées à un quiz
func (qr *QuizRepository) getQuestionsForQuiz(quizId string) ([]map[string]interface{}, error) {
	// Exécution de la requête pour récupérer les questions liées à un quiz
	rows, err := qr.db.Query(`SELECT "questionId", "question" FROM "Questions" WHERE "quizId" = $1`, quizId)
	if err != nil {
		return nil, fmt.Errorf("failed to query questions: %w", err)
	}
	defer rows.Close()

	var questions []map[string]interface{}
	// Parcours des lignes des questions
	for rows.Next() {
		var questionId, question string
		// Extraction des données de chaque ligne
		if err := rows.Scan(&questionId, &question); err != nil {
			return nil, fmt.Errorf("failed to scan question row: %w", err)
		}

		// Création d'un objet pour la question
		questionData := map[string]interface{}{
			"questionId": questionId,
			"question":   question,
		}

		// Ajout de la question au tableau
		questions = append(questions, questionData)
	}

	// Vérifie si une erreur s'est produite pendant l'itération
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating question rows: %w", err)
	}

	return questions, nil
}

// SaveQuiz saves a quiz, its questions, and their answers in the database.
// It inserts data into the following tables (named in lowercase as generated by Prisma):
// - Quizzes (columns: quizId, quiz)
// - Questions (columns: questionId, question, quizId)
// - Answers (columns: answerId, answer, isCorrect, questionId)
func (qr *QuizRepository) SaveQuiz(q Quiz) error {
	tx, err := qr.db.Begin()
	if err != nil {
		return err
	}

	// Generate an identifier for the quiz (similar to the @default(cuid()) directive in Prisma)
	quizId := cuid.New()

	// Insert into the quizzes table
	_, err = tx.Exec(`INSERT INTO "Quizzes" ("quizId", "quiz") VALUES ($1, $2)`, quizId, q.Name)
	if err != nil {
		tx.Rollback()
		return err
	}

	// For each question in the quiz...
	for _, question := range q.Questions {
		questionId := cuid.New()

		// Insert into the Questions table with the foreign key quizId
		_, err := tx.Exec(`INSERT INTO "Questions" ("questionId", "question", "quizId") VALUES ($1, $2, $3)`, questionId, question.Question, quizId)
		if err != nil {
			tx.Rollback()
			return err
		}

		// For each answer in the question...
		for _, answer := range question.Answers {
			answerId := cuid.New()

			// Insert into the Answers table with the foreign key questionId
			_, err := tx.Exec(`INSERT INTO "Answers" ("answerId", "answer", "isCorrect", "questionId") VALUES ($1, $2, $3, $4)`, answerId, answer.Answer, answer.IsCorrect, questionId)
			if err != nil {
				tx.Rollback()
				return err
			}
		}
	}

	// Commit the transaction
	return tx.Commit()
}
